// Everyone had such small answers... Well now I do too!
#include <stdio.h>
#include <stdlib.h>
#define BUFFSIZE 8192 * 2 
#define COLUMNS 12
#define ROWS 1000
typedef struct Data { char *bits[ROWS]; int length; } Data; char sigBit(char *a[], int length, int index, char bit); Data partB(Data data, char bit); int main(int arc, char **argv) { FILE *input; input = fopen(argv[1], "r"); char buffer[BUFFSIZE]; fread(buffer, BUFFSIZE, 1, input); int bits[COLUMNS]; int offset = 0; char *binaryArray[ROWS]; for (int i = 0; i < ROWS; i++) { binaryArray[i] = malloc(sizeof *binaryArray[i] * COLUMNS); } for (int index = 0; index < BUFFSIZE && buffer[index] != '\0'; index++) { if (buffer[index] == '0') { bits[(index - offset) % COLUMNS]++; binaryArray[(int)(index - offset) / COLUMNS][(index - offset) % COLUMNS] = '0'; } else if (buffer[index] == '1') { binaryArray[(int)(index - offset) / COLUMNS][(index - offset) % COLUMNS] = '1'; } else { offset++; } } fclose(input); char gammaStr[COLUMNS + 1]; char epsilonStr[COLUMNS + 1]; for (int i = 0; i < COLUMNS; i++) { gammaStr[i] = (bits[i] > ROWS / 2) ? '0' : '1'; epsilonStr[i] = (bits[i] <= ROWS / 2) ? '0' : '1'; } gammaStr[COLUMNS] = '\0'; epsilonStr[COLUMNS] = '\0'; long gamma = strtol(gammaStr, NULL, 2); long epsilon = strtol(epsilonStr, NULL, 2); printf("gammaStr: %s, epsilonStr: %s\n", gammaStr, epsilonStr); printf("Part A Solution\nGamma: %lu, Epsilon: %lu, Solution: %lu\n\n", gamma, epsilon, gamma * epsilon); Data data; data.length = ROWS; for (int row = 0; row < ROWS; row++) { data.bits[row] = binaryArray[row]; } Data carbon = partB(data, '0'); Data oxygen = partB(data, '1'); char *carbonStr = carbon.bits[0]; char *oxygenStr = oxygen.bits[0]; long carbonInt = strtol(carbonStr, NULL, 2); long oxygenInt = strtol(oxygenStr, NULL, 2); printf("oxygenStr: %s, carbonStr: %s\n", oxygenStr, carbonStr); printf("Part B Solution\nOxygen: %lu, Carbon: %lu, Solution: %lu\n\n", oxygenInt, carbonInt, oxygenInt * carbonInt); return 0; } Data partB(Data data, char bit) { int index = 0; while (data.length > 1 && index < COLUMNS) { Data temp; temp.length = 0; char mask; mask = sigBit(data.bits, data.length, index, bit); for(int row = 0; row < data.length; row++) { if(data.bits[row][index] == mask) { temp.bits[temp.length] = data.bits[row]; temp.length++; } } for(int row = 0; row < temp.length; row++) { data.bits[row] = temp.bits[row]; } data.length = temp.length; index++; } return data; } char sigBit(char *a[], int length, int index, char bit) { int ones = 0; for (int row = 0; row < length; row++) { if (a[row][index] == '1') { ones++; } } if(ones > length - ones) { return (bit == '0') ? '0' : '1'; } else if(ones == length - ones) { return bit; } else { return (bit == '0') ? '1' : '0'; } }